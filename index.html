<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebXR Plane Detection for Virtual Painting</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
</head>
<body style="margin: 0; overflow: hidden;">

<script>
  if (navigator.xr) {
    navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
      if (supported) {
        initXR();
      } else {
        alert('WebXR AR is not supported on your device.');
      }
    });
  } else {
    alert('WebXR is not supported on this browser.');
  }

  async function initXR() {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
    scene.add(light);

    const textureLoader = new THREE.TextureLoader();
    const imageTexture = textureLoader.load('https://via.placeholder.com/400'); // Replace with your painting image URL

    const imageMaterial = new THREE.MeshBasicMaterial({ map: imageTexture });
    const imageGeometry = new THREE.PlaneGeometry(1, 1); // 1x1 meter plane for the painting
    const painting = new THREE.Mesh(imageGeometry, imageMaterial);

    // Initialize WebXR Session
    const session = await navigator.xr.requestSession('immersive-ar', {
      requiredFeatures: ['hit-test', 'plane-detection']
    });
    renderer.xr.setSession(session);

    const referenceSpace = await session.requestReferenceSpace('local');
    const viewerSpace = await session.requestReferenceSpace('viewer');
    const hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

    // Plane Detection - Keep track of detected planes
    const planes = new Map();

    session.addEventListener('select', () => {
      // When user taps the screen, place the painting on the closest detected plane
      const frame = renderer.xr.getFrame();
      const hitTestResults = frame.getHitTestResults(hitTestSource);

      if (hitTestResults.length > 0) {
        const hit = hitTestResults[0];
        const pose = hit.getPose(referenceSpace);

        // Position and rotate the painting on the detected plane
        painting.position.set(
          pose.transform.position.x,
          pose.transform.position.y,
          pose.transform.position.z
        );
        painting.quaternion.set(
          pose.transform.orientation.x,
          pose.transform.orientation.y,
          pose.transform.orientation.z,
          pose.transform.orientation.w
        );

        // Ensure the painting is added to the scene
        if (!scene.children.includes(painting)) {
          scene.add(painting);
        }
      }
    });

    session.addEventListener('planesdetected', (event) => {
      // Update detected planes
      event.planes.forEach((plane) => {
        if (!planes.has(plane.planeId)) {
          const planeMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(1, 1),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide, opacity: 0.3, transparent: true })
          );
          scene.add(planeMesh);
          planes.set(plane.planeId, planeMesh);
        }

        // Update plane mesh positions
        const planeMesh = planes.get(plane.planeId);
        const pose = plane.planePose;
        planeMesh.position.set(pose.position.x, pose.position.y, pose.position.z);
        planeMesh.quaternion.set(
          pose.orientation.x,
          pose.orientation.y,
          pose.orientation.z,
          pose.orientation.w
        );

        // Adjust plane size based on its boundaries
        const { width, height } = plane.planeBounds;
        planeMesh.scale.set(width, height, 1);
      });
    });

    renderer.setAnimationLoop(() => {
      renderer.render(scene, camera);
    });
  }
</script>

</body>
</html>
